# src/config.py
import os
from dotenv import load_dotenv
from supabase import create_client, Client
 
load_dotenv()  # loads .env from project root
 
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
 
def get_supabase() -> Client:
    """
    Return a supabase client. Raises RuntimeError if config missing.
    """
    if not SUPABASE_URL or not SUPABASE_KEY:
        raise RuntimeError("SUPABASE_URL and SUPABASE_KEY must be set in environment (.env)")
    return create_client(SUPABASE_URL, SUPABASE_KEY)
 
 
# src/cli/main.py
import argparse
import json
from src.services import product_service, order_service
from src.dao import product_dao, customer_dao
 
def cmd_product_add(args):
    try:
        p = product_service.add_product(args.name, args.sku, args.price, args.stock, args.category)
        print("Created product:")
        print(json.dumps(p, indent=2, default=str))
    except Exception as e:
        print("Error:", e)
 
def cmd_product_list(args):
    ps = product_dao.list_products(limit=100)
    print(json.dumps(ps, indent=2, default=str))
 
def cmd_customer_add(args):
    try:
        c = customer_dao.create_customer(args.name, args.email, args.phone, args.city)
        print("Created customer:")
        print(json.dumps(c, indent=2, default=str))
    except Exception as e:
        print("Error:", e)
 
def cmd_order_create(args):
    # items provided as prod_id:qty strings
    items = []
    for item in args.item:
        try:
            pid, qty = item.split(":")
            items.append({"prod_id": int(pid), "quantity": int(qty)})
        except Exception:
            print("Invalid item format:", item)
            return
    try:
        ord = order_service.create_order(args.customer, items)
        print("Order created:")
        print(json.dumps(ord, indent=2, default=str))
    except Exception as e:
        print("Error:", e)
 
def cmd_order_show(args):
    try:
        o = order_service.get_order_details(args.order)
        print(json.dumps(o, indent=2, default=str))
    except Exception as e:
        print("Error:", e)
 
def cmd_order_cancel(args):
    try:
        o = order_service.cancel_order(args.order)
        print("Order cancelled (updated):")
        print(json.dumps(o, indent=2, default=str))
    except Exception as e:
        print("Error:", e)
 
def build_parser():
    parser = argparse.ArgumentParser(prog="retail-cli")
    sub = parser.add_subparsers(dest="cmd")
 
    # product add/list
    p_prod = sub.add_parser("product", help="product commands")
    pprod_sub = p_prod.add_subparsers(dest="action")
    addp = pprod_sub.add_parser("add")
    addp.add_argument("--name", required=True)
    addp.add_argument("--sku", required=True)
    addp.add_argument("--price", type=float, required=True)
    addp.add_argument("--stock", type=int, default=0)
    addp.add_argument("--category", default=None)
    addp.set_defaults(func=cmd_product_add)
 
    listp = pprod_sub.add_parser("list")
    listp.set_defaults(func=cmd_product_list)
 
    # customer add
    pcust = sub.add_parser("customer")
    pcust_sub = pcust.add_subparsers(dest="action")
    addc = pcust_sub.add_parser("add")
    addc.add_argument("--name", required=True)
    addc.add_argument("--email", required=True)
    addc.add_argument("--phone", required=True)
    addc.add_argument("--city", default=None)
    addc.set_defaults(func=cmd_customer_add)
 
    # order
    porder = sub.add_parser("order")
    porder_sub = porder.add_subparsers(dest="action")
 
    createo = porder_sub.add_parser("create")
    createo.add_argument("--customer", type=int, required=True)
    createo.add_argument("--item", required=True, nargs="+", help="prod_id:qty (repeatable)")
    createo.set_defaults(func=cmd_order_create)
 
    showo = porder_sub.add_parser("show")
    showo.add_argument("--order", type=int, required=True)
    showo.set_defaults(func=cmd_order_show)
 
    cano = porder_sub.add_parser("cancel")
    cano.add_argument("--order", type=int, required=True)
    cano.set_defaults(func=cmd_order_cancel)
 
    return parser
 
def main():
    parser = build_parser()
    args = parser.parse_args()
    if not hasattr(args, "func"):
        parser.print_help()
        return
    args.func(args)
 
if __name__ == "__main__":
    main()
 
 
# src/services/product_service.py
from typing import List, Dict
import src.dao.product_dao as product_dao
 
class ProductError(Exception):
    pass
 
def add_product(name: str, sku: str, price: float, stock: int = 0, category: str | None = None) -> Dict:
    """
    Validate and insert a new product.
    Raises ProductError on validation failure.
    """
    if price <= 0:
        raise ProductError("Price must be greater than 0")
    existing = product_dao.get_product_by_sku(sku)
    if existing:
        raise ProductError(f"SKU already exists: {sku}")
    return product_dao.create_product(name, sku, price, stock, category)
 
def restock_product(prod_id: int, delta: int) -> Dict:
    if delta <= 0:
        raise ProductError("Delta must be positive")
    p = product_dao.get_product_by_id(prod_id)
    if not p:
        raise ProductError("Product not found")
    new_stock = (p.get("stock") or 0) + delta
    return product_dao.update_product(prod_id, {"stock": new_stock})
 
def get_low_stock(threshold: int = 5) -> List[Dict]:
    allp = product_dao.list_products(limit=1000)
    return [p for p in allp if (p.get("stock") or 0) <= threshold]
 
 
# src/dao/product_dao.py
from typing import Optional, List, Dict
from src.config import get_supabase
 
def _sb():
    return get_supabase()
 
def create_product(name: str, sku: str, price: float, stock: int = 0, category: str | None = None) -> Optional[Dict]:
    """
    Insert a product and return the inserted row (two-step: insert then select by unique sku).
    """
    payload = {"name": name, "sku": sku, "price": price, "stock": stock}
    if category is not None:
        payload["category"] = category
 
    # Insert (no select chaining)
    _sb().table("products").insert(payload).execute()
 
    # Fetch inserted row by unique column (sku)
    resp = _sb().table("products").select("*").eq("sku", sku).limit(1).execute()
    return resp.data[0] if resp.data else None
 
def get_product_by_id(prod_id: int) -> Optional[Dict]:
    resp = _sb().table("products").select("*").eq("prod_id", prod_id).limit(1).execute()
    return resp.data[0] if resp.data else None
 
def get_product_by_sku(sku: str) -> Optional[Dict]:
    resp = _sb().table("products").select("*").eq("sku", sku).limit(1).execute()
    return resp.data[0] if resp.data else None
 
def update_product(prod_id: int, fields: Dict) -> Optional[Dict]:
    """
    Update and then return the updated row (two-step).
    """
    _sb().table("products").update(fields).eq("prod_id", prod_id).execute()
    resp = _sb().table("products").select("*").eq("prod_id", prod_id).limit(1).execute()
    return resp.data[0] if resp.data else None
 
def delete_product(prod_id: int) -> Optional[Dict]:
    # fetch row before delete (so we can return it)
    resp_before = _sb().table("products").select("*").eq("prod_id", prod_id).limit(1).execute()
    row = resp_before.data[0] if resp_before.data else None
    _sb().table("products").delete().eq("prod_id", prod_id).execute()
    return row
 
def list_products(limit: int = 100, category: str | None = None) -> List[Dict]:
    q = _sb().table("products").select("*").order("prod_id", desc=False).limit(limit)
    if category:
        q = q.eq("category", category)
    resp = q.execute()
    return resp.data or []
 
 
-- Customers table
CREATE TABLE IF NOT EXISTS customers (
    cust_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    phone TEXT NOT NULL,
    city TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);
 
-- Products table
CREATE TABLE IF NOT EXISTS products (
    prod_id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    sku TEXT UNIQUE NOT NULL,
    price NUMERIC(10,2) NOT NULL CHECK (price > 0),
    stock INT NOT NULL DEFAULT 0,
    category TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);
 
-- Orders table
CREATE TABLE IF NOT EXISTS orders (
    order_id SERIAL PRIMARY KEY,
    cust_id INT REFERENCES customers(cust_id) ON DELETE CASCADE,
    order_date TIMESTAMPTZ DEFAULT now(),
    status TEXT DEFAULT 'PLACED',
    total_amount NUMERIC(12,2)
);
 
-- Order Items table
CREATE TABLE IF NOT EXISTS order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,
    prod_id INT REFERENCES products(prod_id),
    quantity INT NOT NULL CHECK (quantity > 0),
    price NUMERIC(10,2) NOT NULL
);
 
-- Payments table
CREATE TABLE IF NOT EXISTS payments (
    payment_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,
    amount NUMERIC(12,2),
    method TEXT,
    paid_at TIMESTAMPTZ,
    status TEXT
);
 
 
python -m src.cli.main product add --name "Mouse" --sku "M-001" --price 599 --stock 20 --category "Accessories"
 
create table public.orders (
  order_id serial not null,
  cust_id integer null,
  order_date timestamp with time zone null default now(),
  status text null default 'PLACED'::text,
  total_amount numeric(12, 2) null,
  constraint orders_pkey primary key (order_id),
  constraint orders_cust_id_fkey foreign KEY (cust_id) references customers (cust_id) on delete CASCADE
) TABLESPACE pg_default;
 
Customers Module
Scenario:

The store now wants to manage customer information. Each customer can place multiple orders. You must build features to handle Customer Management.
Tasks:
Create a new customer with details → name, email, phone, city.
Validate that email must be unique.
If email already exists, show an error.
Update a customer’s phone or city.
Delete a customer:
Allow deletion only if the customer has no orders.
If orders exist, block deletion with an error message.
List all customers.
Search customer by email or city.
 
To check Product List:
python -m src.cli.main product list
 
Add a customer:
python -m src.cli.main customer add --name "Rahul" --email "rahul@example.com" --phone "9999999999" --city "Hyderabad"
 
Orders Module
Scenario:

A customer comes to buy products. The system must create an order, assign products to it, calculate total amount, and manage stock.
Tasks:
Create a new order for a customer.
Input: customer_id and a list of products with quantities (e.g., [{prod_id: 1, qty: 2}, {prod_id: 3, qty: 1}]).
Check that the customer exists.
Check each product’s stock → if not enough stock, reject order with error.
Deduct stock for purchased products.
Insert order into orders table and order_items table.
Save the total_amount.
Fetch full details of an order (order info + customer info + order items).
List all orders of a customer.
Cancel an order:
Allowed only if status = PLACED.
Restore product stock.
Update order status = CANCELLED.
Mark an order as Completed after payment is successful
 
Payments Module:
Scenario:

The store now wants to track payments for each order.
Tasks:
When an order is created, insert a pending payment record with the total amount.
Process payment → mark payment as PAID with method (Cash/Card/UPI).
Update the order status to COMPLETED.
Support refunds: If an order is cancelled, mark the payment as REFUNDED.
Reporting Module 
Scenario:

The manager wants to see sales reports.
Tasks:
Show top 5 selling products (by total quantity).
Show total revenue in the last month.
Show total orders placed by each customer.
Show customers who placed more than 2 orders.
 